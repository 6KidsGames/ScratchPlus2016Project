<!doctype html>
<!-- Based on Echo sample from Primus. -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Zomb Attack</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/normalize/3.0.1/normalize.min.css">
  <script src="/primus/primus.js"></script>
  <script src="/scripts/hexi.min.js"></script>
  <script src="/scripts/game.js"></script>
  <style>
    body { padding: 5px }
    #output { display: block; border: 0; outline: 0; margin: 0 0 4px }
    #textMessage { width: 400px; height: 25px; font-size: 16px }
    button { border-radius: 5px; border: 0; background: #444; color: #FFF; padding: 6px }
  </style>
</head>
<body>
  <form id="chatForm">
    <input placeholder="Write message to other players" id="textMessage" />
    <button type="submit">Send</button>
  </form>
  <textarea id="output" rows="3" cols="60" readonly></textarea>
  <p>
    Copyright &#169; 2016 6KidsGames.com
  </p>
  <script>
    var output = document.getElementById('output');
    output.value = '';
    var textMessage = document.getElementById('textMessage');

    // Track the latest world updates from the server's world update messages.
    // We start with an empty world until the server can get a first message
    // back to us.
    var currentWorld = createEmptyWorldUpdate();
    var scrollingTileCamera = null;
    var currentLevelName = null;
    var levelWorldObj = null;

    // Sound and graphics files we want to load via Hexi.js.
    var thingsToLoadIntoHexi = [
      // Sound files.

      "Sounds/CreepyBackgroundMusic.mp3",
      "Sounds/character1(girl)_hurt_0.mp3",
      "Sounds/character1(girl)_hurt_1.mp3",
      "Sounds/character2(boy)_hurt_0.mp3",
      "Sounds/character2(boy)_hurt_1.mp3",

      // CODESYNC: Zombie.js keeps this list as well.
      'Sounds/ZombieGrowl1.mp3',
      'Sounds/ZombieGrowl2.mp3',
      'Sounds/zombieHurt0.mp3',
      
      // Spritesheet and tileset JSON metadata files and related PNGs.
      'images/ZombAttackSpritesheet.json',
      'images/ZombAttackTileset.png',

      // Game map definitions in Tiled Editor (http://mapeditor.org) comma-separated value (CSV) JSON
      // format, suitable for use with Hexi's GameUtilities.
      'Levels/SpawnCity.json',
      'Levels/theFarm.json',
    ];
    
    // Hexi.js (and Pixi.js) setup. Pixi will autodetect the browser's capabilities and
    // choose the fastest renderer (WebGL or HTML5 Canvas).
    var hexiObj = hexi(window.innerWidth, window.innerHeight, hexiSetupCompleted, thingsToLoadIntoHexi, hexiLoading);
    hexiObj.fps = 30;  // Game logic loop runs at this rate. Sprites still render at 60 fps.
    hexiObj.backgroundColor = 0x000000;  // black
    hexiObj.scaleToWindow();
    hexiObj.start();

    var zombieGrowls = [];
    var zombieHurtSounds = [];
    var characterHurtSounds = [];

    // User interface spites.
    var playerHealthSprite = undefined;
    var playerWeaponSprite = undefined;

    function hexiLoading() {
      console.log(`Loading: ${hexiObj.loadingFile} (${hexiObj.loadingProcess}%)`);
      hexiObj.loadingBar();  // TODO: Keep?
    }

    function hexiSetupCompleted() {
      console.log("Hexi setup complete");

      // CODESYNC: The number of sounds here is set in Zombie.js numGrowlSounds
      zombieGrowls[0] = hexiObj.sound('Sounds/ZombieGrowl1.mp3');
      zombieGrowls[1] = hexiObj.sound('Sounds/ZombieGrowl2.mp3');

      // CODESYNC: The number of sounds here is set in Zombie.js numHurtSounds
      zombieHurtSounds[0] = hexiObj.sound('Sounds/zombieHurt0.mp3');

      // CODESYNC: The number of sounds here is set in RunNodeSiteServer.js numPlayerHurtSounds
      characterHurtSounds[0] = [
        hexiObj.sound('Sounds/character1(girl)_hurt_0.mp3'),
        hexiObj.sound('Sounds/character1(girl)_hurt_1.mp3'),
      ];
      characterHurtSounds[1] = [
        hexiObj.sound('Sounds/character2(boy)_hurt_0.mp3'),
        hexiObj.sound('Sounds/character2(boy)_hurt_1.mp3'),
      ];

      logo1Setup();
    }

    var logo1Sprite = undefined;
    var logo1Start;
    function logo1Setup() {
      logo1Start = (new Date()).getTime();
      logo1Sprite = hexiObj.sprite("6KidsLogo");
      logo1Sprite.alpha = 0;
      logo1Sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
      hexiObj.stage.putCenter(logo1Sprite);
      hexiObj.state = logo1Loop;
    }
    function logo1Loop() {
      var now = (new Date()).getTime();
      var dt = now - logo1Start;
      if (dt < 1000) {
        logo1Sprite.alpha = (dt / 1000) * (dt / 1000);
      } else if (dt < 2000) {
        logo1Sprite.alpha = 1;
      } else if (dt < 3000) {
        logo1Sprite.alpha = (1000 - (dt - 2000)) / 1000;
      } else {
        hexiObj.remove(logo1Sprite);
        logo2Setup();
      }
    }

    var logo2Sprite = undefined;
    var logo2Start;
    function logo2Setup() {
      logo2Start = (new Date()).getTime();
      logo2Sprite = hexiObj.sprite("ZombAttackLogo1");
      logo2Sprite.alpha = 0;
      logo2Sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
      hexiObj.stage.putCenter(logo2Sprite);
      hexiObj.state = logo2Loop;

      // Start creepy music at the start of the ZombAttack logo.
      var music = hexiObj.sound("Sounds/CreepyBackgroundMusic.mp3");
      music.loop = true;
      music.fadeIn(1);
      music.volume = 0.5;
      music.play();
    }
    function logo2Loop() {
      var now = (new Date()).getTime();
      var dt = now - logo2Start;
      if (dt < 1000) {
        logo2Sprite.alpha = (dt / 1000) * (dt / 1000);
      } else if (dt < 2000) {
        logo2Sprite.alpha = 1;
      } else if (dt < 3000) {
        logo2Sprite.alpha = (1000 - (dt - 2000)) / 1000;
      } else {
        hexiObj.remove(logo2Sprite);
        gameLoopSetup();
      }
    }

    function gameLoopSetup() {
      playerHealthSprite = hexiObj.text("HEALTH: ", "32px sans-serif", "white", 10, 10);
      playerHealthSprite.alpha = 0.5;
      playerHealthSprite.layer = 1000;  // Foremost

      playerWeaponSprite = hexiObj.text("Weapon: ", "32px sans-serif", "white", 10, 45);
      playerWeaponSprite.alpha = 0.5;
      playerWeaponSprite.layer = 1000;  // Foremost
      
      hexiObj.state = gameLoop;
    }

    // Tell Primus to create a new WebSockets connection to the current domain/port/protocol.
    // Get the primus connection spark ID when we connect - we need it for knowing which player
    // we are in the world state passed from the server. 
    var primus = Primus.connect();
    var currentPrimusSparkID;
    primus.on("open", function () {
      console.log("Connected to server through Primus.");
      primus.id(function (id) {
        currentPrimusSparkID = id;
        console.log("Current Primus spark ID: " + id);
      });
    });

    function nameOrUnknown(name) {
      if (name) return name;
      return "Unknown";
    }
    
    // Listen for incoming messages from the server.
    primus.on('data', function received(data) {
      if (data.type === 'text') {
        // Place text messages in our textarea element.
        output.value += nameOrUnknown(data.player) + ': ' + data.message + '\n';
        output.scrollTop = output.scrollHeight;  // Follow messages at bottom of text area.
      }
      else if (data.type == 'update') {
        // console.log("Received world update:", data);
        currentWorld = data;
      }
      else {
        console.log("Received unknown message type " + data.type)
      }
    });

    // Listen for submits of the form so we can send the message to the server.
    document.getElementById('chatForm').onsubmit = function submit(e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      primus.write({
        type: 'text',
        message: textMessage.value
      });
      textMessage.value = '';
    };

    // Helpers that track the state of keyboard keys by hooking the current window's key events
    // and tracking if a key down or up has occurred.
    var keyPressed = [];
    window.onkeyup = function(keyEvent) { /*console.log("keyup: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = false; }
    window.onkeydown = function(keyEvent) { /*console.log("keydown: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = true; }

    // Key codes. Full table at http://www.cambiaresearch.com/articles/15/javascript-key-codes
    var KEY_W = 87;
    var KEY_S = 83;
    var KEY_A = 65;
    var KEY_D = 68;
    var KEY_SPACE = 32;
    var KEY_E = 69;
    var KEY_R = 82;
    
    // Keep a copy of the last PlayerControlInfo message sent, so we don't send
    // a new message if there has been no change since the last one.
    var prevControlInfo = { };

    // Keep a copy of the last game world update we processed in gameLoop().
    // Each time through the loop, a new world update might have appeared
    // including new or removed players.
    var lastProcessedWorldUpdate = createEmptyWorldUpdate();

    // Keep a record of all players we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed players. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var playerDatas = { };
    function forEachPlayerData(func) {
      var ids = Object.keys(playerDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (playerDatas.hasOwnProperty(id)) {
          var playerData = playerDatas[id]; 
          if (playerData) {
            func(playerData);
          }
        }
      }
    }

    // Keep a record of all weapons we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed weapons. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var weaponDatas = { };
    function forEachWeaponData(func) {
      var ids = Object.keys(weaponDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (weaponDatas.hasOwnProperty(id)) {
          var weaponData = weaponDatas[id]; 
          if (weaponData) {
            func(weaponData);
          }
        }
      }
    }

    // Keep a record of all zombies in play right now.
    var zombieDatas = { };
    function forEachZombieData(func) {
      var ids = Object.keys(zombieDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (zombieDatas.hasOwnProperty(id)) {
          var zombieData = zombieDatas[id]; 
          if (zombieData) {
            func(zombieData);
          }
        }
      }
    }

    // Called 30 times per second by the Hexi main loop.
    function gameLoop() {
      var startTime = (new Date()).getTime();

      // Create a new, empty PlayerControlInfo message to send to the server
      // with our current control status.
      var controlInfo = {
        type: 'ctrl',
      };

      // Create tile world object if we have never updated a level before, or if we changed levels.
      // Must come early in loop logic since we need to add and update sprites as children of the level object.
      if (currentLevelName !== currentWorld.lvl) {
        console.log(`Loading level ${currentWorld.lvl}`);
        currentLevelName = currentWorld.lvl;
        levelWorldObj = hexiObj.makeTiledWorld("Levels/" + currentWorld.lvl + ".json", 'images/ZombAttackTileset.png');
        levelWorldObj.layer = 0;  // Rearmost.
      }

      // Mark all players we are tracking as touched=false to detect removed players.
      forEachPlayerData(function(playerData) { playerData.touched = false; });

      // Make changes to player sprites from the current world state sent by the server.
      var myPlayerData  = null;
      for (var i = 0; i < currentWorld.p.length; i++) {
        var player = currentWorld.p[i];

        // Player might be new. If so, create a new sprite.
        var playerData = null;
        if (!playerDatas.hasOwnProperty(player.id)) {
          playerData = {
            id: player.id,
            lastSoundCount: player.sndC,  // On reconnect, we don't want a ton of sounds, so use the current server count and play the next ones sent.
            sprite: createNewPlayerSprite(),
          };

          playerDatas[player.id] = playerData;
        }
        else {
          playerData = playerDatas[player.id];
        }
        playerData.touched = true;

        if (myPlayerData == null && player.id === currentPrimusSparkID) {
          myPlayerData = playerData;

          // It's hard to tell the current player amongst all the others.
          // Add a translucent circle centered on the local player. 
          if (!myPlayerData.markedForBetterViewing) {
            var highlightCircle = hexiObj.circle(diameter = 64);
            highlightCircle.alpha = 0.3;
            highlightCircle.pivot.x = 16;
            highlightCircle.pivot.y = 16;
            myPlayerData.sprite.addChild(highlightCircle);
            myPlayerData.markedForBetterViewing = true;
          }
        }

        // Update the sprite with current world information.
        playerData.sprite.x = player.x;
        playerData.sprite.y = player.y;
        playerData.sprite.rotation = player.dir;
        playerData.lastHealth = playerData.health;
        playerData.health = player.hl;
        playerData.lastWeapon = playerData.weapon;
        playerData.weapon = player.wpn;
        if (player.dead && !playerData.dead) {
          // TODO: Make a sound.
          playerData.dead = true;
        }

        if (player.sndC > playerData.lastSoundCount) {
          playerData.lastSoundCount = player.sndC;
          characterHurtSounds[0][player.snd].play();
        }
      }

      if (myPlayerData.health !== myPlayerData.lastHealth) {
        playerHealthSprite.content = "HEALTH: " + myPlayerData.health;
      }

      if (myPlayerData.weapon !== myPlayerData.lastWeapon) {
        playerWeaponSprite.content = "WEAPON: " + myPlayerData.weapon;
      }

      // Find any playerDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachPlayerData(function(playerData) {
        if (!playerData.touched) {
          console.log("Removing player", playerData.id, playerData.name, "from the world");
          playerData.sprite.visible = false;
          hexiObj.remove(playerData.sprite);
          playerDatas[playerData.id] = undefined;
        }
      });

      // Mark all weapons we are tracking as touched=false to detect removed weapons.
      forEachWeaponData(function(weaponData) { weaponData.touched = false; });

      // Make changes to weapon sprites from the current world state sent by the server.
      for (var i = 0; i < currentWorld.w.length; i++) {
        var weapon = currentWorld.w[i];

        // Weapon might be new. If so, create a new sprite.
        var weaponData = null;
        if (!weaponDatas.hasOwnProperty(weapon.id)) {
          weaponData = {
            id: weapon.id,
            sprite: createNewWeaponSprite(weapon),
          };

          weaponDatas[weapon.id] = weaponData;
        }
        else {
          weaponData = weaponDatas[weapon.id];
        }
        weaponData.touched = true;
      }
    
      // Find any weaponDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachWeaponData(function(weaponData) {
        if (!weaponData.touched) {
          console.log("Removing weapon", weapon.id, "from the world");
          weaponData.sprite.visible = false;
          hexiObj.remove(weaponData.sprite);
          weaponDatas[weaponData.id] = undefined;
        }
      });

      // Mark all zombies we are tracking as touched=false to detect removed zombies.
      forEachZombieData(function(zombieData) { zombieData.touched = false; });

      // Process zombie changes sent by the server.
      for (var i = 0; i < currentWorld.z.length; i++) {
        var zombie = currentWorld.z[i];

        // If new, create a new sprite.
        var zombieData = null;
        if (!zombieDatas.hasOwnProperty(zombie.id)) {
          zombieData = {
            id: zombie.id,
            sprite: createNewZombieSprite(zombie),
            serverZombieInfo: zombie,
            lastGrowlCount: zombie.growlC,  // On reconnect, we don't want a ton of growls, so use the current server count and play the next ones sent.
            lastHurtCount: zombie.hurtC,
            lastHealth: zombie.hl,
          };
          zombieDatas[zombie.id] = zombieData;
        }
        else {
          zombieData = zombieDatas[zombie.id];
        }
        zombieData.touched = true;

        // See if the growlCount is newer than our last known update, and if so, start a growl sound.
        if (zombie.growlC > zombieData.lastGrowlCount) {
          zombieData.lastGrowlCount = zombie.growlC;
          console.log(`Z${zombie.id} playing growl ${zombie.growl}`);
          zombieGrowls[zombie.growl].play();
        }

        if (zombie.hurtC > zombieData.lastHurtCount) {
          zombieData.lastHurtCount = zombie.hurtC;
          console.log(`Z${zombie.id} playing hurt sound ${zombie.hurt}`);
          zombieHurtSounds[zombie.hurt].play();
        }
        
        // Update the sprite with current world information.
        zombieData.sprite.x = zombie.x;
        zombieData.sprite.y = zombie.y;
        zombieData.sprite.rotation = zombie.dir;
      }

      // Find any zombieDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachZombieData(function(zombieData) {
        if (!zombieData.touched) {
          console.log("Removing zombie", zombieData.id, "from the world");
          zombieData.sprite.visible = false;
          hexiObj.remove(zombieData.sprite);
          zombieDatas[zombieData.id] = undefined;
        }
      });

      if (scrollingTileCamera === null) {
        scrollingTileCamera = hexiObj.worldCamera(levelWorldObj, currentWorld.lvlW, currentWorld.lvlH);
        scrollingTileCamera.centerOver(myPlayerData.sprite);
      }

      // Control keys don't change anything locally, we send to the server and it
      // determines what happens.
      if (keyPressed[KEY_W]) { controlInfo.fwd = true; }
      if (keyPressed[KEY_S]) { controlInfo.back = true; }
      if (keyPressed[KEY_A]) { controlInfo.turnLeft = true; }
      if (keyPressed[KEY_D]) { controlInfo.turnRight = true; }
      if (keyPressed[KEY_SPACE]) { controlInfo.useWeapon = true; }

      // Send the control update to the game server if it's different from the last update.
      // TODO: This should be handled asynchronously instead of in the game
      // loop to avoid slowing down local animation.
      if (!objects_equal(controlInfo, prevControlInfo)) {
        primus.write(controlInfo);
        prevControlInfo = controlInfo;
      }

      // Keep the local player's sprite centered on the screen, and move the level map around the player.
      scrollingTileCamera.follow(myPlayerData.sprite);

      var processingTimeMsec = (new Date()).getTime() - startTime;
      if (processingTimeMsec > 50) {
        console.log(`Excessive loop processing time: ${processingTimeMsec} ms`);
      }
    }

    function createNewPlayerSprite() {
      console.log("Creating player sprite");
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, "vplayer"), 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.pivot.x = 15;
      sprite.pivot.y = 22;
      sprite.layer = 100;  // Frontmost

      return sprite;
    }
  
    // Map from zombie costume numbers into texture names.
    // CODESYNC: Numeric keys are mapped in Zombie.js.
    var ZombieCostumeIDMap = {
      0: "crawler_",
      1: "vcrawlerzombie",
      2: "czombie_",
      3: "vnormalzombie",
    }; 

    function createNewZombieSprite(serverZombieInfo) {
      var costumeName = ZombieCostumeIDMap[serverZombieInfo.cstm];
      console.log("Creating zombie Z" + serverZombieInfo.id + " with costume " + costumeName +
          " at (" + serverZombieInfo.x + "," + serverZombieInfo.y + ")");
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, costumeName), 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.position.x = serverZombieInfo.x;
      sprite.position.y = serverZombieInfo.y;
      sprite.pivot.x = 16;
      sprite.pivot.y = 16;
      sprite.layer = 10;  // Behind player but in front of map tiles.

      return sprite;
    }

    // Map from weapon numbers into texture names.
    // CODESYNC: Numeric keys are mapped in Weapon.js.
    var WeaponNumberMap = {
      0: "vdagger",
      1: "vHalligan",
      2: "vsword",
      3: "vchainsaw",
      4: "vpistol",
      5: "vrifle",
      6: "vmachinegun",
      7: "vminigun",
    }; 

    function createNewWeaponSprite(serverWeaponInfo) {
      var costumeName = WeaponNumberMap[serverWeaponInfo.n];
      console.log("Creating weapon W" + serverWeaponInfo.id + " with costume " + costumeName +
          " at (" + serverWeaponInfo.x + "," + serverWeaponInfo.y + ")");
      var sprite = hexiObj.sprite(costumeName, 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.position.x = serverWeaponInfo.x;
      sprite.position.y = serverWeaponInfo.y;
      sprite.layer = 5;  // Behind player and zombies but in front of map tiles.

      return sprite;
    }

    function createEmptyWorldUpdate() {
      return {
        p: [],
        z: [],
        w: [],
      };
    }

    // Modified from article below, augmented with array validation.
    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249
    function objects_equal(x, y) {
      if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

      if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

      if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

      if (Array.isArray(x)) {
        if (!Array.isArray(y)) return false;
        if (x.length != y.length) return false;
        for (var i = 0; i < x.length; i++) {
          if (!objects_equal(x[i], y[i])) return false;
        }
      }

      for ( var p in x ) {
        if ( ! x.hasOwnProperty( p ) ) continue;
          // other properties were tested using x.constructor === y.constructor

        if ( ! y.hasOwnProperty( p ) ) return false;
          // allows to compare x[ p ] and y[ p ] when set to undefined

        var xprop = x[p];
        var yprop = y[p];

        if ( xprop === yprop ) continue;
          // if they have the same strict value or identity then they are equal

        if ( typeof(xprop) !== "object" ) return false;
          // Numbers, Strings, Functions, Booleans must be strictly equal

        if (!objects_equal(xprop, yprop)) return false;
          // Objects and Arrays must be tested recursively
      }

      for ( p in y ) {
        if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
          // allows x[ p ] to be set to undefined
      }
      return true;
    }

    // Returns a random integer between min (included) and max (excluded)
    // Using Math.round() will give you a non-uniform distribution!
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min)) + min;
    }
  </script>
</body>
</html>
