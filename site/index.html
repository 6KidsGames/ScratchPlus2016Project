<!doctype html>
<!-- Based on Echo sample from Primus. -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ScratchPlus Summer 2016 Project</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/normalize/3.0.1/normalize.min.css">
  <script src="/primus/primus.js"></script>
  <script src="/scripts/pixi.min.js"></script>
  <style>
    body { padding: 5px }
    #output { display: block; border: 0; outline: 0; margin: 0 0 4px }
    #textMessage { width: 400px; height: 25px; font-size: 16px }
    button { border-radius: 5px; border: 0; background: #444; color: #FFF; padding: 6px }
  </style>
</head>
<body>
  <input placeholder="Player name" id="playerName"></input>
  <p>
    Use A,S,D,W to move, Space to inflate, E to reset, R to rotate, G to become a ghost, T to change color,
    B to go forward faster, V to go backward faster, C to go up faster, N to go down faster.
  </p>
  <div id="gameArea"></div>
  <form id="chatForm">
    <input placeholder="Write message to other players" id="textMessage" />
    <button type="submit">Send</button>
  </form>
  <textarea id="output" rows="3" cols="60" readonly></textarea>
  
  <script>
    var output = document.getElementById('output');
    output.value = '';
    var textMessage = document.getElementById('textMessage');
    var playerName = document.getElementById('playerName');
    var gameArea = document.getElementById('gameArea');

    // Track the latest world updates from the server's worldUpdate messages.
    // We start with an empty world until the server can get a first message
    // back to us.
    var currentWorld = createEmptyWorldUpdate();

    // Pixi.js setup - we use Pixi's auto-detect for the browser's capabilities.
    // It will choose a fast WebGL viewport or fall back to HTML5 Canvas. 
    console.log(PIXI);
    var renderer = PIXI.autoDetectRenderer(800, 128, { antialias: false, transparent: false, resolution: 1 });
    renderer.autoResize = true;
    gameArea.appendChild(renderer.view);
    renderer.resize(window.innerWidth, 500);
    var stage = new PIXI.Container();
    PIXI.loader
      .add([ "images/BananaDoesNotApprove.png" ])
      .load(setupPixi);

    // Called asynchronously when PIXI.loader.load() has finished loading all textures and we can create sprites.
    function setupPixi() {
      // Image load complete. Create sprites from the tileset.
      console.log("Pixi setup complete, creating stage");
      // console.log(PIXI.loader.resources);
      renderer.render(stage);

      // Run the game loop from here on out.
      gameLoop();
    }

    // Tell Primus to create a new WebSockets connection to the current domain/port/protocol
    var primus = Primus.connect();
    primus.on("open", function () {
      console.log("Connected to server through Primus.");
    });

    function nameOrUnknown(name) {
      if (name) return name;
      return "Unknown";
    }
    
    // Listen for incoming messages from the server.
    primus.on('data', function received(data) {
      if (data.type === 'text') {
        // Place text messages in our textarea element.
        output.value += nameOrUnknown(data.player) + ': ' + data.message + '\n';
        output.scrollTop = output.scrollHeight;  // Follow messages at bottom of text area.
      }
      else if (data.type == 'worldUpdate') {
        // console.log("Received world update:", data);
        currentWorld = data;
      }
      else {
        console.log("Received unknown message type " + data.type)
      }
    });

    // Listen for submits of the form so we can send the message to the server.
    document.getElementById('chatForm').onsubmit = function submit(e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      primus.write({
        type: 'text',
        player: playerName.value,
        message: textMessage.value
      });
      textMessage.value = '';
    };

    // Helpers that track the state of keyboard keys by hooking the current window's key events
    // and tracking if a key down or up has occurred.
    var keyPressed = [];
    window.onkeyup = function(keyEvent) { /*console.log("keyup: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = false; }
    window.onkeydown = function(keyEvent) { /*console.log("keydown: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = true; }

    // Key codes. Full table at http://www.cambiaresearch.com/articles/15/javascript-key-codes
    var KEY_W = 87;
    var KEY_S = 83;
    var KEY_A = 65;
    var KEY_D = 68;
    var KEY_SPACE = 32;
    var KEY_E = 69;
    var KEY_R = 82;
    var KEY_G = 71;
    var KEY_T = 84;
    var KEY_B = 66;
    var KEY_V = 86;
    var KEY_N = 78;
    var KEY_C = 67;
    var KEY_J = 74;
    
    // Keep a copy of the last PlayerControlInfo message sent, so we don't send
    // a new message if there has been no change since the last one.
    var prevControlInfo = { };

    // Keep a copy of the last game world update we processed in gameLoop().
    // Each time through the loop, a new world update might have appeared
    // including new or removed players.
    var lastProcessedWorldUpdate = createEmptyWorldUpdate();

    // Keep a record of all players we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed players. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var playerDatas = { };
    function forEachPlayerData(func) {
      var ids = Object.keys(playerDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (playerDatas.hasOwnProperty(id)) {
          var playerData = playerDatas[id]; 
          if (playerData) {
            func(playerData);
          }
        }
      }
    }

    function gameLoop() {
      // This call returns when we're at the beginning of the next frame time.
      // Rendering is at 60 frames per second by default, which is fast enough not to appear flickery.
      requestAnimationFrame(gameLoop);

      // Create a new, empty PlayerControlInfo message to send to the server
      // with our current control status.
      var controlInfo = {
        type: 'PlayerControlInfo',
        name: playerName.value  // Current player name as typed into the web page. Can change any time.
      };

      // Mark all players we are tracking as touched=false to detect removed players.
      forEachPlayerData(function(playerData) { playerData.touched = false; });

      // Make changes to sprites from the current world state sent by the server.
      for (var i = 0; i < currentWorld.players.length; i++) {
        var player = currentWorld.players[i];

        // Player might be new. If so, create a new sprite.
        var playerData = null;
        if (!playerDatas.hasOwnProperty(player.id)) {
          playerData = {
            sprite: createNewPlayerSprite()
          };
          playerDatas[player.id] = playerData;
        }
        else {
          playerData = playerDatas[player.id];
        }
        playerData.touched = true;

        // Update the sprite with current world information.
        playerData.sprite.x = player.currentPosition.x;
        playerData.sprite.y = player.currentPosition.y;
        playerData.sprite.scale.x = player.scale;
        playerData.sprite.scale.y = player.scale;
      }

      // Find any playerDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachPlayerData(function(playerData) {
        if (!playerData.touched) {
          console.log("Removing player", playerData.id, playerData.name, "from the world");
          playerData.sprite.visible = false;
          stage.removeChild(playerData.sprite);
          playerDatas[playerData.id] = undefined;
        }
      });

      // Control keys don't change anything locally, we send to the server and it
      // determines what happens.
      if (keyPressed[KEY_W]) { controlInfo.upPressed = true; }
      if (keyPressed[KEY_S]) { controlInfo.downPressed = true; }
      if (keyPressed[KEY_A]) { controlInfo.leftPressed = true; }
      if (keyPressed[KEY_D]) { controlInfo.rightPressed = true; }
      if (keyPressed[KEY_SPACE]) { controlInfo.inflatePressed = true; }
      
      // TODO: bananaSprite no longer exists. This means keys below will not work.
      var bananaSprite = null;
      if (keyPressed[KEY_E]) {
        bananaSprite.scale.x = 0.5;
        bananaSprite.scale.y = 0.5;
        bananaSprite.x = 0;
        bananaSprite.y = 0;
        bananaSprite.alpha = 1;
        bananaSprite.rotation = 0;
        bananaSprite.tint = 0xffffff;
      }
      if (keyPressed[KEY_R]) { bananaSprite.rotation += 0.1; }
      if (keyPressed[KEY_G]) { bananaSprite.alpha *= 0.97; }
      if (keyPressed[KEY_T]) { bananaSprite.tint =  0xff00ff; }

      // TODO: These are not hooked up the server and the server updates will
      // overwrite any changes made here. Either hook up to the server as
      // "fast control keys", or remove.
      if (keyPressed[KEY_B]) { bananaSprite.x += 10; }
      if (keyPressed[KEY_V]) { bananaSprite.x -= 10; }
      if (keyPressed[KEY_N]) { bananaSprite.y += 5; }
      if (keyPressed[KEY_C]) { bananaSprite.y -= 5; }

      // Send the control update to the game server if it's different from the last update.
      // TODO: This should be handled asynchronously instead of in the game
      // loop to avoid slowing down local animation.
      if (!objects_equal(controlInfo, prevControlInfo)) {
        primus.write(controlInfo);
        prevControlInfo = controlInfo;
      }

      // Render the results to the stage.
      renderer.render(stage);
    }

    function createNewPlayerSprite() {
      var sprite  = new PIXI.Sprite(PIXI.loader.resources["images/BananaDoesNotApprove.png"].texture);
      stage.addChild(sprite);
      sprite.scale.x = 0.5;
      sprite.scale.y = 0.5;
      return sprite;
    }

    function createEmptyWorldUpdate() {
      return { players: [] };
    }

    // Modified from article below, augmented with array validation.
    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249
    function objects_equal(x, y) {
      if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

      if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

      if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

      if (Array.isArray(x)) {
        if (!Array.isArray(y)) return false;
        if (x.length != y.length) return false;
        for (var i = 0; i < x.length; i++) {
          if (!objects_equal(x[i], y[i])) return false;
        }
      }

      for ( var p in x ) {
        if ( ! x.hasOwnProperty( p ) ) continue;
          // other properties were tested using x.constructor === y.constructor

        if ( ! y.hasOwnProperty( p ) ) return false;
          // allows to compare x[ p ] and y[ p ] when set to undefined

        var xprop = x[p];
        var yprop = y[p];

        if ( xprop === yprop ) continue;
          // if they have the same strict value or identity then they are equal

        if ( typeof(xprop) !== "object" ) return false;
          // Numbers, Strings, Functions, Booleans must be strictly equal

        if (!objects_equal(xprop, yprop)) return false;
          // Objects and Arrays must be tested recursively
      }

      for ( p in y ) {
        if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
          // allows x[ p ] to be set to undefined
      }
      return true;
    }

  </script>
</body>
</html>
