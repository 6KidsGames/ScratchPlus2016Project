<!doctype html>
<!-- Based on Echo sample from Primus. -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ScratchPlus Summer 2016 Project</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/normalize/3.0.1/normalize.min.css">
  <script src="/primus/primus.js"></script>
  <script src="/scripts/hexi.min.js"></script>
  <script src="/scripts/game.js"></script>
  <style>
    body { padding: 5px }
    #output { display: block; border: 0; outline: 0; margin: 0 0 4px }
    #textMessage { width: 400px; height: 25px; font-size: 16px }
    button { border-radius: 5px; border: 0; background: #444; color: #FFF; padding: 6px }
  </style>
</head>
<body>
  <input placeholder="Player name" id="playerName"></input>
  <p>
    Use A,S,D,W to move, Space to inflate, E to reset, R to rotate, G to become a ghost, T to change color.
  </p>
  <div id="gameArea"></div>
  <form id="chatForm">
    <input placeholder="Write message to other players" id="textMessage" />
    <button type="submit">Send</button>
  </form>
  <textarea id="output" rows="3" cols="60" readonly></textarea>
  <p>
    Copyright &#169; 2016 6KidsGames.com
  </p>
  <script>
    var output = document.getElementById('output');
    output.value = '';
    var textMessage = document.getElementById('textMessage');
    var playerName = document.getElementById('playerName');
    var gameArea = document.getElementById('gameArea');

    var datetimeObj = new Date();

    // Track the latest world updates from the server's worldUpdate messages.
    // We start with an empty world until the server can get a first message
    // back to us.
    var currentWorld = createEmptyWorldUpdate();
    var scrollingTileCamera = null;
    var currentLevelName = null;
    var levelWorldObj = null;

    // Sound and graphics files we want to load via Hexi.js.
    var thingsToLoadIntoHexi = [
      // Sound files.

      // CODESYNC: Zombie.js keeps this list as well.
      'Sounds/ZombieGrowl1.mp3',
      'Sounds/ZombieGrowl2.mp3',
      
      // Spritesheet and tileset JSON metadata files and related PNGs.
      'images/ZombieDefenseSpritesheet.json',
      'images/ZombieDefenseTileset.png',

      // Game maps definitions in Tiled Editor (http://mapeditor.org) comma-separated value (CSV)
      // format, suitable for use with Hexi's GameUtilities.
      'Levels/SpawnCity.json',
    ];
    
    // Hexi.js (and Pixi.js) setup. Pixi will autodetect the browser's capabilities and
    // choose the fastest renderer (WebGL or HTML5 Canvas).
    var hexiObj = hexi(window.innerWidth, window.innerHeight, hexiSetupCompleted, thingsToLoadIntoHexi, hexiLoading);
    hexiObj.fps = 30;  // Game logic loop runs at this rate. Sprites still render at 60 fps.
    hexiObj.backgroundColor = 0x000000;  // black
    hexiObj.scaleToWindow();
    hexiObj.start();

    var zombieGrowlMap = { };  // Path to Hexi Sound.js object.

    function hexiLoading() {
      console.log(`Loading: ${hexiObj.loadingFile} (${hexiObj.loadingProcess}%)`);
      hexiObj.loadingBar();  // TODO: Keep?
    }

    function hexiSetupCompleted() {
      console.log("Hexi setup complete");

      zombieGrowlMap['Sounds/ZombieGrowl1.mp3'] = hexiObj.sound('Sounds/ZombieGrowl1.mp3');
      zombieGrowlMap['Sounds/ZombieGrowl2.mp3'] = hexiObj.sound('Sounds/ZombieGrowl2.mp3');

      hexiObj.state = gameLoop;
    }

    // Tell Primus to create a new WebSockets connection to the current domain/port/protocol.
    // Get the primus connection spark ID when we connect - we need it for knowing which player
    // we are in the world state passed from the server. 
    var primus = Primus.connect();
    var currentPrimusSparkID;
    primus.on("open", function () {
      console.log("Connected to server through Primus.");
      primus.id(function (id) {
        currentPrimusSparkID = id;
        console.log("Current Primus spark ID: " + id);
      });
    });

    function nameOrUnknown(name) {
      if (name) return name;
      return "Unknown";
    }
    
    // Listen for incoming messages from the server.
    primus.on('data', function received(data) {
      if (data.type === 'text') {
        // Place text messages in our textarea element.
        output.value += nameOrUnknown(data.player) + ': ' + data.message + '\n';
        output.scrollTop = output.scrollHeight;  // Follow messages at bottom of text area.
      }
      else if (data.type == 'worldUpdate') {
        // console.log("Received world update:", data);
        currentWorld = data;
      }
      else {
        console.log("Received unknown message type " + data.type)
      }
    });

    // Listen for submits of the form so we can send the message to the server.
    document.getElementById('chatForm').onsubmit = function submit(e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      primus.write({
        type: 'text',
        player: playerName.value,
        message: textMessage.value
      });
      textMessage.value = '';
    };

    // Helpers that track the state of keyboard keys by hooking the current window's key events
    // and tracking if a key down or up has occurred.
    var keyPressed = [];
    window.onkeyup = function(keyEvent) { /*console.log("keyup: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = false; }
    window.onkeydown = function(keyEvent) { /*console.log("keydown: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = true; }

    // Key codes. Full table at http://www.cambiaresearch.com/articles/15/javascript-key-codes
    var KEY_W = 87;
    var KEY_S = 83;
    var KEY_A = 65;
    var KEY_D = 68;
    var KEY_SPACE = 32;
    var KEY_E = 69;
    var KEY_R = 82;
    var KEY_G = 71;
    var KEY_T = 84;
    var KEY_B = 66;
    var KEY_V = 86;
    var KEY_N = 78;
    var KEY_C = 67;
    var KEY_J = 74;
    
    // Keep a copy of the last PlayerControlInfo message sent, so we don't send
    // a new message if there has been no change since the last one.
    var prevControlInfo = { };

    // Keep a copy of the last game world update we processed in gameLoop().
    // Each time through the loop, a new world update might have appeared
    // including new or removed players.
    var lastProcessedWorldUpdate = createEmptyWorldUpdate();

    // Keep a record of all players we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed players. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var playerDatas = { };
    function forEachPlayerData(func) {
      var ids = Object.keys(playerDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (playerDatas.hasOwnProperty(id)) {
          var playerData = playerDatas[id]; 
          if (playerData) {
            func(playerData);
          }
        }
      }
    }

    // Keep a record of all zombies in play right now.
    var zombieDatas = { };
    function forEachZombieData(func) {
      var ids = Object.keys(zombieDatas);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (zombieDatas.hasOwnProperty(id)) {
          var zombieData = zombieDatas[id]; 
          if (zombieData) {
            func(zombieData);
          }
        }
      }
    }

    // Called 30 times per second by the Hexi main loop.
    function gameLoop() {
      var startTime = datetimeObj.getTime();

      // Create a new, empty PlayerControlInfo message to send to the server
      // with our current control status.
      var controlInfo = {
        type: 'PlayerControlInfo',
        name: playerName.value  // Current player name as typed into the web page. Can change any time.
      };

      // Create tile world object if we have never updated a level before, or if we changed levels.
      // Must come early in loop logic since we need to add and update sprites as children of the level object.
      if (currentLevelName !== currentWorld.levelName) {
        currentLevelName = currentWorld.levelName;
        levelWorldObj = hexiObj.makeTiledWorld("Levels/" + currentWorld.levelName + ".json", 'images/ZombieDefenseTileset.png');
        levelWorldObj.layer = 0;  // Rearmost.
      }

      // Mark all players we are tracking as touched=false to detect removed players.
      forEachPlayerData(function(playerData) { playerData.touched = false; });

      // Make changes to sprites from the current world state sent by the server.
      var myPlayerData  = null;
      for (var i = 0; i < currentWorld.players.length; i++) {
        var player = currentWorld.players[i];

        // Player might be new. If so, create a new sprite.
        var playerData = null;
        if (!playerDatas.hasOwnProperty(player.id)) {
          playerData = {
            id: player.id,
            sprite: createNewPlayerSprite()
          };
          playerDatas[player.id] = playerData;
        }
        else {
          playerData = playerDatas[player.id];
        }
        playerData.touched = true;

        if (myPlayerData == null && player.id === currentPrimusSparkID) {
          myPlayerData = playerData;
        }

        // Update the sprite with current world information.
        playerData.sprite.x = player.currentPosition.x;
        playerData.sprite.y = player.currentPosition.y;
        playerData.sprite.scale.x = player.scale;
        playerData.sprite.scale.y = player.scale;
        playerData.sprite.alpha = player.alpha;
        playerData.sprite.rotation = player.rotation;
        playerData.sprite.tint = player.tint;
      }

      // Find any playerDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachPlayerData(function(playerData) {
        if (!playerData.touched) {
          console.log("Removing player", playerData.id, playerData.name, "from the world");
          playerData.sprite.visible = false;
          hexiObj.remove(playerData.sprite);
          playerDatas[playerData.id] = undefined;
        }
      });

      // Mark all zombies we are tracking as touched=false to detect removed zombies.
      forEachZombieData(function(zombieData) { zombieData.touched = false; });

      // Process zombie changes sent by the server.
      for (var i = 0; i < currentWorld.zombies.length; i++) {
        var zombie = currentWorld.zombies[i];

        // If new, create a new sprite.
        var zombieData = null;
        if (!zombieDatas.hasOwnProperty(zombie.id)) {
          zombieData = {
            id: zombie.id,
            sprite: createNewZombieSprite(zombie),
            serverZombieInfo: zombie,
            lastGrowlCount: zombie.growlCount,  // On reconnect, we don't want a ton of growls, so use the current server count and play the next ones sent.
          };
          zombieDatas[zombie.id] = zombieData;
        }
        else {
          zombieData = zombieDatas[zombie.id];
        }
        zombieData.touched = true;

        // See if the growlCount is newer than our last known update, and if so, start a growl sound.
        if (zombie.growlCount > zombieData.lastGrowlCount) {
          zombieData.lastGrowlCount = zombie.growlCount;
          console.log("Playing growl", zombie.growlSound)
          zombieGrowlMap[zombie.growlSound].play();
        }

        // Update the sprite with current world information.
        zombieData.sprite.x = zombie.currentPosition.x;
        zombieData.sprite.y = zombie.currentPosition.y;
        zombieData.sprite.rotation = zombie.rotation;
      }

      // Find any zombieDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachZombieData(function(zombieData) {
        if (!zombieData.touched) {
          console.log("Removing zombie", zombieData.id, "from the world");
          zombieData.sprite.visible = false;
          hexiObj.remove(zombieData.sprite);
          zombieDatas[zombieData.id] = undefined;
        }
      });

      if (scrollingTileCamera === null) {
        scrollingTileCamera = hexiObj.worldCamera(levelWorldObj, currentWorld.size.width, currentWorld.size.height);
        scrollingTileCamera.centerOver(myPlayerData.sprite);
      }

      // Control keys don't change anything locally, we send to the server and it
      // determines what happens.
      if (keyPressed[KEY_W]) { controlInfo.forwardPressed = true; }
      if (keyPressed[KEY_S]) { controlInfo.backwardPressed = true; }
      if (keyPressed[KEY_A]) { controlInfo.rotationLeftPressed = true; }
      if (keyPressed[KEY_SPACE]) { controlInfo.inflatePressed = true; }
      if (keyPressed[KEY_G]) { controlInfo.ghostPressed = true; }
      if (keyPressed[KEY_D]) { controlInfo.rotationRightPressed = true; }
      if (keyPressed[KEY_T]) { controlInfo.tintPressed = true; }
      if (keyPressed[KEY_E]) { controlInfo.resetPressed = true; }
      
      // Send the control update to the game server if it's different from the last update.
      // TODO: This should be handled asynchronously instead of in the game
      // loop to avoid slowing down local animation.
      if (!objects_equal(controlInfo, prevControlInfo)) {
        primus.write(controlInfo);
        prevControlInfo = controlInfo;
      }

      // Keep the local player's sprite centered on the screen, and move the level map around the player.
      scrollingTileCamera.follow(myPlayerData.sprite);

      var processingTimeMsec = datetimeObj.getTime() - startTime;
      if (processingTimeMsec > 50) {
        console.log("Excessive loop processing time: ${processingTimeMsec} ms");
      }
    }

    function createNewPlayerSprite() {
      console.log("Creating player sprite");
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, "vplayer"), 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.scale.x = 1.0;
      sprite.scale.y = 1.0;
      sprite.pivot.x = 15;
      sprite.pivot.y = 22;
      sprite.layer = 100;  // Frontmost

      return sprite;
    }
  
    function createNewZombieSprite(serverZombieInfo) {
      console.log("Creating " + serverZombieInfo.type + " zombie (ID=" + serverZombieInfo.id +
          ") with costume " + serverZombieInfo.costume +
          " at (" + serverZombieInfo.currentPosition.x + "," + serverZombieInfo.currentPosition.y + ")");
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, serverZombieInfo.costume), 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.position = serverZombieInfo.currentPosition;
      sprite.pivot.x = 15;
      sprite.pivot.y = 22;
      sprite.layer = 10;  // Behind player.

      return sprite;
    }

    function createEmptyWorldUpdate() {
      return {
        players: [],
        zombies: [],
      };
    }

    // Modified from article below, augmented with array validation.
    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249
    function objects_equal(x, y) {
      if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

      if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

      if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

      if (Array.isArray(x)) {
        if (!Array.isArray(y)) return false;
        if (x.length != y.length) return false;
        for (var i = 0; i < x.length; i++) {
          if (!objects_equal(x[i], y[i])) return false;
        }
      }

      for ( var p in x ) {
        if ( ! x.hasOwnProperty( p ) ) continue;
          // other properties were tested using x.constructor === y.constructor

        if ( ! y.hasOwnProperty( p ) ) return false;
          // allows to compare x[ p ] and y[ p ] when set to undefined

        var xprop = x[p];
        var yprop = y[p];

        if ( xprop === yprop ) continue;
          // if they have the same strict value or identity then they are equal

        if ( typeof(xprop) !== "object" ) return false;
          // Numbers, Strings, Functions, Booleans must be strictly equal

        if (!objects_equal(xprop, yprop)) return false;
          // Objects and Arrays must be tested recursively
      }

      for ( p in y ) {
        if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
          // allows x[ p ] to be set to undefined
      }
      return true;
    }

    // Returns a random integer between min (included) and max (excluded)
    // Using Math.round() will give you a non-uniform distribution!
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min)) + min;
    }

  </script>
</body>
</html>
